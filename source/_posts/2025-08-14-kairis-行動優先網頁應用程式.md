---
title: Kairis App 開發實戰指南：智慧投資應用全攻略
date: 2025-08-14 16:15:12
subtitle: 從需求到部署，整合AI金融科技
categories:
  - Web Development
tags:
  - web-development
  - fintech
  - ai
  - stock-trading
  - software-development-lifecycle
cover_index: https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=450&h=450&fit=crop&crop=center
---

# Kairis App 開發實作指南

本文件旨在將 Kairis App 的產品需求文件 (PRD) 轉換為一份詳盡的開發實作指南。我們將從需求分析開始，逐步深入到技術架構設計、資料庫規劃、API 介面定義、核心功能實作、前端介面開發、測試策略，以及最終的部署上線流程，旨在為開發團隊提供清晰的實作路徑。

## 1. PRD 需求分析

Kairis App 是一款專為散戶投資者設計的行動優先網頁應用程式 (SPA)，核心目標是提供一個簡潔高效的平台，用於追蹤美股與台股、自動掃描交易機會，並結合 AI 智慧解讀，輔助投資決策。

**核心功能點：**

*   **產品定位**：行動優先的 SPA，深色主題，底部頁籤導覽。
*   **目標用戶**：對美股、台股有基本認識，依賴技術分析與 AI 輔助的散戶投資者。
*   **自選列表 (Watchlist)**：
    *   市場分頁：美股/台股切換。
    *   股票管理：新增 (自動補綴 .US/.TW)、刪除 (確認提示)。
    *   股票卡片顯示：名稱、代號、即時價格、漲跌、高低價、3/5/10日均線（低於均線顯示星號壓力提示）。
    *   排序：依股票代號字母/數字順序。
    *   更新：顯示「最後更新時間」。
*   **機會掃描 (Scanner)**：
    *   市場分頁：美股/台股切換。
    *   機會卡片：股票名稱、代號、即時價格、漲跌幅、觸發條件列表、1-3分量化力度評分。
    *   排序：依力度由高至低。
    *   力度評估邏輯：綜合價格 (RSI, 布林通道)、趨勢 (均線)、動能 (MACD 交叉)、成交量 (價量關係) 四個面向。
*   **個股詳情頁 (Detail View)**：
    *   呈現方式：全螢幕覆蓋層，返回按鈕。
    *   核心資訊：即時價格、漲跌幅、高低價、成交量。
    *   內容分頁：分析、圖表、新聞。
    *   分析分頁：七日價格區間、技術指標參考 (RSI, MACD, 布林通道, 量價關係)、Gemini AI 智慧解讀（即時生成，修正跑版）。
    *   圖表分頁：30日 K 線圖 (OHLC)、日線/週線切換。
    *   新聞分頁：即時新聞、AI 自動翻譯英文標題並截斷。

**非功能性需求：**

*   **性能**：即時數據更新，快速響應。
*   **可用性**：直觀易用，行動裝置優化。
*   **穩定性**：可靠的數據來源與服務運行。
*   **安全性**：用戶數據（自選股）安全儲存。

## 2. 技術架構設計

Kairis App 採用現代化的前後端分離架構，結合 Serverless 技術，以實現高效、可擴展且成本效益高的應用程式。

![Kairis App Architecture Diagram (Conceptual)](https://i.imgur.com/example_architecture.png "Conceptual Architecture Diagram - Please imagine a diagram here.")
*概念架構圖：使用者前端 (SPA) <-> Vercel Serverless Functions <-> (Finnhub, Alpha Vantage, Gemini APIs) & Google Firebase (Firestore)*

**2.1 整體架構**

*   **前端 (Client-side)**：基於純 HTML、CSS (Tailwind CSS) 和 Vanilla JavaScript 開發的單頁應用程式 (SPA)。負責用戶介面渲染、用戶互動邏輯以及與後端 API 的通訊。
*   **後端 (Backend)**：採用 Vercel Serverless Functions。這些函數作為前端與外部第三方 API (Finnhub, Alpha Vantage, Gemini) 及資料庫 (Firebase Firestore) 之間的中介層。它們負責數據聚合、業務邏輯處理（如機會掃描的指標計算、AI 呼叫）和數據安全。
*   **資料庫 (Database)**：Google Firebase Firestore，用於儲存用戶的自選股列表，並利用其匿名登入功能簡化用戶管理。
*   **外部 API 整合**：
    *   **Finnhub**: 提供美股即時報價、公司新聞。
    *   **Alpha Vantage**: 提供穩定的每日歷史 K 線數據。
    *   **Gemini API**: 提供 AI 智慧解讀和新聞標題翻譯能力。
*   **部署 (Deployment)**：程式碼託管於 GitHub，並透過 Vercel 進行自動化部署，實現 CI/CD。

**2.2 技術選型考量**

*   **前端 (HTML, CSS/Tailwind, Vanilla JS)**：
    *   **優勢**：輕量級，無需大型框架的額外開銷，啟動速度快，對行動裝置友好。Vanilla JS 提供最大的靈活性和控制力。Tailwind CSS 加速 UI 開發，並確保一致的設計系統。
    *   **適用性**：符合行動優先的 SPA 需求，尤其適合快速原型開發和對性能有較高要求的應用。
*   **後端 (Vercel Serverless Functions)**：
    *   **優勢**：按需執行，無需管理伺服器，自動擴展，成本效益高（只為實際使用付費）。非常適合作為 API 聚合層，處理來自多個外部 API 的數據並進行輕量級處理。
    *   **適用性**：作為前端和外部服務之間的橋樑，處理敏感 API Key，聚合數據，執行複雜的計算邏輯（如掃描器）。
*   **資料庫 (Firebase Firestore)**：
    *   **優勢**：NoSQL 文件型資料庫，實時同步，易於擴展。特別適合儲存用戶配置和列表數據。匿名登入功能簡化了用戶認證流程。
    *   **適用性**：儲存用戶的自選股列表，快速讀寫。
*   **外部 API**：
    *   **Finnhub / Alpha Vantage**：選擇這兩者是為了兼顧即時數據和穩定的歷史數據來源。
    *   **Gemini API**：利用其強大的自然語言處理能力，提供智能分析和翻譯服務。

## 3. 資料庫設計 (Google Firebase Firestore)

Kairis App 主要使用 Firebase Firestore 來儲存用戶的自選股列表。由於採用匿名登入，每個匿名用戶會獲得一個唯一的 `uid`，此 `uid` 將作為 Firestore 中的文檔 ID。

**3.1 集合 (Collection) 與文檔 (Document) 結構**

*   **集合名稱**: `users`
*   **文檔 ID**: 匿名用戶的 `uid` (例如: `users/some_anonymous_user_id`)
*   **文檔內容**:
    *   `watchlist`: 儲存用戶自選股票代號的陣列。每個代號包含市場後綴 (例如: `AAPL.US`, `2330.TW`)。
    *   `lastUpdatedAt`: (可選) 記錄用戶自選股列表最後更新時間的 Timestamp。

**3.2 範例資料結構**

```json
// Collection: users
// Document ID: anon_user_abcdefg12345
{
  "watchlist": [
    "AAPL.US",
    "MSFT.US",
    "NVDA.US",
    "2330.TW",
    "2303.TW"
  ],
  "lastUpdatedAt": "2023-10-27T10:30:00Z" // ISO 8601 format or Firebase Timestamp
}

// Another Document ID: anon_user_hijklmn67890
{
  "watchlist": [
    "GOOG.US",
    "TSLA.US"
  ],
  "lastUpdatedAt": "2023-10-27T09:45:00Z"
}
```

**3.3 Firestore 安全規則 (Security Rules)**

為了確保數據安全，需要配置 Firestore 安全規則，允許用戶只能讀寫自己的 `watchlist`。

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      // Allow read/write only if the request's auth UID matches the document ID
      allow read, write: if request.auth.uid == userId;
    }
  }
}
```
*說明：這條規則確保了每個用戶只能存取和修改他們自己的 `users/{userId}` 文檔，防止未經授權的數據存取。*

## 4. API 接口設計 (Vercel Serverless Functions)

Serverless Functions 作為應用程式的後端，負責處理來自前端的請求，並協調與外部 API 和 Firebase 的交互。以下是主要的 API 端點設計。

**基礎路徑**: `/api`

**4.1 用戶與自選股管理**

*   **`POST /api/auth/anonymous`**
    *   **描述**: 執行 Firebase 匿名登入，獲取用戶 UID。
    *   **請求**: 無
    *   **響應**: `{"uid": "string"}`
    *   **處理邏輯**: 呼叫 Firebase Admin SDK 進行匿名登入。
*   **`GET /api/watchlist`**
    *   **描述**: 獲取當前用戶的自選股列表及其即時數據。
    *   **請求**: `headers: {"Authorization": "Bearer <firebase_id_token>"}`
    *   **響應**: `Array<StockData>`
        ```json
        [
          {
            "symbol": "AAPL.US",
            "name": "Apple Inc.",
            "price": 170.12,
            "change": 1.50,
            "percentChange": 0.89,
            "high": 170.50,
            "low": 168.00,
            "ma3": 169.00,
            "ma5": 168.50,
            "ma10": 167.00,
            "isPressure3": false,
            "isPressure5": false,
            "isPressure10": true,
            "lastUpdatedAt": "2023-10-27 10:30:00"
          }
        ]
        ```
    *   **處理邏輯**:
        1.  驗證 `id_token`，獲取 `uid`。
        2.  從 Firestore 讀取 `users/{uid}/watchlist`。
        3.  遍歷 `watchlist` 中的股票代號。
        4.  對每個股票，呼叫 Finnhub (即時報價) 和 Alpha Vantage (歷史 K 線用於計算均線)。
        5.  計算 3/5/10 日均線，並判斷是否為壓力位。
        6.  聚合數據並返回。
*   **`POST /api/watchlist`**
    *   **描述**: 向用戶自選股列表添加股票。
    *   **請求**: `headers: {"Authorization": "Bearer <firebase_id_token>"}, body: {"symbol": "string"}`
    *   **響應**: `{"success": true, "message": "Stock added."}` 或 `{"success": false, "error": "message"}`
    *   **處理邏輯**:
        1.  驗證 `id_token`，獲取 `uid`。
        2.  從 Firestore 讀取 `watchlist`。
        3.  檢查是否已存在，若否則添加股票代號到陣列中。
        4.  更新 Firestore 文檔。
*   **`DELETE /api/watchlist`**
    *   **描述**: 從用戶自選股列表移除股票。
    *   **請求**: `headers: {"Authorization": "Bearer <firebase_id_token>"}, body: {"symbol": "string"}`
    *   **響應**: `{"success": true, "message": "Stock removed."}` 或 `{"success": false, "error": "message"}`
    *   **處理邏輯**:
        1.  驗證 `id_token`，獲取 `uid`。
        2.  從 Firestore 讀取 `watchlist`。
        3.  從陣列中移除指定股票代號。
        4.  更新 Firestore 文檔。

**4.2 機會掃描**

*   **`GET /api/scanner`**
    *   **描述**: 根據預設策略掃描指定市場的交易機會。
    *   **請求**: `query: {"market": "US" | "TW"}`
    *   **響應**: `Array<OpportunityData>`
        ```json
        [
          {
            "symbol": "TSLA.US",
            "name": "Tesla Inc.",
            "price": 250.00,
            "change": 5.00,
            "percentChange": 2.04,
            "reasons": ["RSI Overbought", "MACD Golden Cross", "Volume Surge"],
            "score": 3
          }
        ]
        ```
    *   **處理邏輯**:
        1.  根據 `market` 參數選擇對應市場的股票池。
        2.  遍歷股票池中的每支股票。
        3.  呼叫 Finnhub/Alpha Vantage 獲取即時和歷史數據。
        4.  計算多種技術指標 (RSI, MACD, 布林通道, 均線)。
        5.  根據 PRD 定義的邏輯評估觸發條件，並給出 1-3 分的力度評分。
        6.  過濾掉不符合條件的股票，將符合條件的股票按力度降序排序。
        7.  聚合數據並返回。

**4.3 個股詳情**

*   **`GET /api/stock/:symbol/details`**
    *   **描述**: 獲取指定股票的詳細信息、K 線數據和技術指標。
    *   **請求**: `params: {"symbol": "string"}, query: {"period": "daily" | "weekly"}`
    *   **響應**: `StockDetailData`
        ```json
        {
          "symbol": "AAPL.US",
          "name": "Apple Inc.",
          "price": 170.12,
          "change": 1.50,
          "percentChange": 0.89,
          "high": 170.50,
          "low": 168.00,
          "volume": 70000000,
          "sevenDayPrices": [ /* array of {date, high, low} */ ],
          "indicators": {
            "RSI": 65.5,
            "MACD": {"macd": 1.2, "signal": 1.0, "histogram": 0.2},
            "BollingerBands": {"upper": 175.0, "middle": 170.0, "lower": 165.0},
            "VolumePriceRelation": "Strong Buy"
          },
          "klineData": [ /* array of {date, open, high, low, close, volume} */ ]
        }
        ```
    *   **處理邏輯**:
        1.  呼叫 Finnhub 獲取即時報價和基本信息。
        2.  呼叫 Alpha Vantage 獲取歷史 K 線數據 (根據 `period` 參數)。
        3.  基於 K 線數據計算 RSI, MACD, 布林通道等指標。
        4.  聚合數據並返回。

*   **`GET /api/stock/:symbol/news`**
    *   **描述**: 獲取指定股票的相關新聞。
    *   **請求**: `params: {"symbol": "string"}`
    *   **響應**: `Array<NewsData>`
        ```json
        [
          {
            "headline": "Apple Q4 Earnings Beat Expectations",
            "translatedHeadline": "蘋果第四季度財報超出預期",
            "url": "https://example.com/news/apple-earnings",
            "source": "Reuters",
            "datetime": "2023-10-26T18:00:00Z"
          }
        ]
        ```
    *   **處理邏輯**:
        1.  呼叫 Finnhub 獲取股票相關新聞。
        2.  遍歷新聞列表，對於英文標題，呼叫 Gemini API 進行翻譯並截斷。
        3.  返回新聞列表。

*   **`POST /api/ai/analyze`**
    *   **描述**: 使用 Gemini AI 對股票數據進行智慧解讀。
    *   **請求**: `body: {"symbol": "string", "data": "object"}` (包含技術指標、價格區間等數據)
    *   **響應**: `{"analysis": "string"}`
    *   **處理邏輯**:
        1.  接收前端傳遞的股票數據。
        2.  構建詳細的 Gemini Prompt，包含股票名稱、當前價格、技術指標數值、七日價格區間等。
        3.  呼叫 Gemini API。
        4.  返回 AI 生成的分析文本。

## 5. 核心功能實作 (Serverless Functions 範例)

以下提供幾個關鍵 Serverless Function 的程式碼範例，使用 Node.js 環境。

**5.1 `api/auth/anonymous.js` (匿名登入)**

```javascript
// api/auth/anonymous.js
import { initializeApp, getApps, getApp } from 'firebase-admin/app';
import { getAuth } from 'firebase-admin/auth';

// 初始化 Firebase Admin SDK
// 確保只初始化一次
if (!getApps().length) {
  initializeApp({
    credential: applicationDefault(), // 需配置 Google Cloud 服務帳戶憑證
  });
}
const auth = getAuth();

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  try {
    const userRecord = await auth.createCustomToken(null); // Create a custom token for anonymous auth
    // Note: Firebase client SDK handles the sign-in with this token.
    // For anonymous sign-in, the client directly calls signInAnonymously.
    // This serverless function might be more useful for creating *custom* tokens for existing users,
    // or if you want to manage anonymous users server-side.
    // For the PRD's "anonymous login", the client-side `signInAnonymously` is usually sufficient.
    // However, if the intent is to manage *which* anonymous users can access,
    // or to generate a token for a specific anonymous ID, this pattern applies.
    // Let's assume for simplicity, the client just uses Firebase's `signInAnonymously`.
    // So this endpoint might be redundant unless there's a specific server-side need for token generation.

    // Re-interpreting the PRD: "支援匿名登入" usually means client-side `signInAnonymously`.
    // The serverless function would then *verify* the client's ID token.
    // Let's provide a token verification example instead.

    return res.status(200).json({ message: "Client should use Firebase client SDK's signInAnonymously." });

  } catch (error) {
    console.error('Error during anonymous login:', error);
    return res.status(500).json({ message: 'Internal Server Error', error: error.message });
  }
}
```
*註解：PRD 中提到的「匿名登入」通常在前端直接使用 Firebase Client SDK 的 `signInAnonymously()` 方法即可。如果此 Serverless Function 的目的是為了生成一個自定義的匿名用戶 ID，或者進行更複雜的身份驗證，則上述範例的 `createCustomToken` 可能適用。但更常見的後端匿名登入相關功能是**驗證**前端傳來的 `id_token`。我們將在 `watchlist` 相關 API 中示範 ID Token 驗證。*

**5.2 `api/watchlist.js` (添加股票)**

```javascript
// api/watchlist.js
import { initializeApp, getApps, getApp } from 'firebase-admin/app';
import { getFirestore } from 'firebase-admin/firestore';
import { getAuth } from 'firebase-admin/auth';

// 初始化 Firebase Admin SDK
if (!getApps().length) {
  initializeApp({
    credential: applicationDefault(),
  });
}
const db = getFirestore();
const auth = getAuth();

export default async function handler(req, res) {
  if (req.method === 'POST') {
    // Add stock to watchlist
    const { symbol } = req.body;
    const authHeader = req.headers.authorization;
    if (!authHeader || !symbol) {
      return res.status(400).json({ message: 'Missing Authorization header or symbol.' });
    }

    const idToken = authHeader.split('Bearer ')[1];
    if (!idToken) {
      return res.status(401).json({ message: 'Invalid Authorization header.' });
    }

    try {
      const decodedToken = await auth.verifyIdToken(idToken);
      const uid = decodedToken.uid;

      const userRef = db.collection('users').doc(uid);
      const doc = await userRef.get();

      let watchlist = [];
      if (doc.exists) {
        watchlist = doc.data().watchlist || [];
      }

      if (watchlist.includes(symbol)) {
        return res.status(409).json({ success: false, message: 'Stock already in watchlist.' });
      }

      watchlist.push(symbol);
      await userRef.set({ watchlist, lastUpdatedAt: new Date().toISOString() }, { merge: true });

      return res.status(200).json({ success: true, message: 'Stock added successfully.' });

    } catch (error) {
      console.error('Error adding stock to watchlist:', error);
      return res.status(500).json({ success: false, message: 'Internal Server Error', error: error.message });
    }
  } else if (req.method === 'DELETE') {
    // Remove stock from watchlist (similar logic to POST, but splice/filter array)
    // ... (omitted for brevity, but follows the same pattern of auth, fetch, modify, update)
    return res.status(405).json({ message: 'Method Not Allowed' }); // Or implement DELETE
  } else if (req.method === 'GET') {
    // Get watchlist data (more complex, involves external APIs)
    // ... (omitted for brevity, see conceptual logic in API design)
    return res.status(405).json({ message: 'Method Not Allowed' }); // Or implement GET
  } else {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }
}
```
*說明：此範例展示了如何驗證 Firebase ID Token 以獲取用戶 UID，然後安全地更新該用戶在 Firestore 中的自選股列表。`GET` 和 `