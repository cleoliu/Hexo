---
title: 廣告合規AI系統開發：從PRD到部署完整指南
date: 2025-08-15 12:40:15
subtitle: 涵蓋需求分析、模型建構與系統實作
categories:
  - AI/ML
tags:
  - AI/ML
  - Machine Learning
  - NLP
  - System Design
  - Compliance
cover_index: https://images.unsplash.com/photo-1499750310107-5fef28a66643?w=450&h=450&fit=crop&crop=center
---

# 廣告違法判斷與分類系統開發實作指南

本文件旨在將現有的廣告違法判斷與分類模型流程，擴展為一份完整的產品需求文件（PRD）及開發實作指南。涵蓋從需求分析、技術架構、資料庫設計、API 接口、核心功能實作、前端介面、測試方案到部署上線的完整軟體開發生命週期。

## 1. PRD 需求分析

### 1.1 專案目標

開發一套自動化系統，用於判斷廣告內容是否違反《投信投顧法》第 70-1 條，並進一步分類違法類型（03、04、05）。旨在提高廣告審核效率，降低人工審核成本，並確保廣告合規性。

### 1.2 功能需求

*   **廣告文字輸入：** 支援單筆文字輸入及批次 CSV 檔案上傳。
*   **兩階段預測：**
    *   **第一階段：** 判斷廣告是否違法（0 = 不違法，1 = 違法）。
    *   **第二階段：** 若第一階段判斷為違法，則進一步分類違法類型（03、04、05）。
*   **預測結果輸出：**
    *   單筆查詢：即時顯示預測結果。
    *   批次查詢：生成包含原始廣告文字、是否違法預測、違法類型預測的 CSV 檔案。
*   **模型管理（後台功能，可選）：**
    *   上傳新的訓練資料。
    *   觸發模型再訓練。
    *   查看模型評估指標（準確率）。

### 1.3 非功能性需求

*   **效能：** 單筆預測響應時間需在秒級，批次處理需高效完成。
*   **準確性：** 模型的預測準確率需達到預期指標（如：第一階段準確率 > 90%，第二階段準確率 > 80%）。
*   **可擴展性：** 系統應能應對未來數據量及請求量的增長。
*   **可靠性：** 系統需穩定運行，具備錯誤處理機制。
*   **安全性：** 保護數據隱私，API 接口需有認證機制。
*   **可用性：** 前端介面需直觀易用。
*   **可維護性：** 程式碼結構清晰，易於理解和修改。

### 1.4 核心業務邏輯

1.  接收廣告文字輸入。
2.  對輸入文字進行預處理（如：分詞、清洗）。
3.  使用預訓練的 TF-IDF 模型將文字轉換為特徵向量。
4.  將特徵向量輸入第一階段 Random Forest 分類器，預測是否違法。
5.  如果第一階段預測為違法（`1`），則將相同的特徵向量輸入第二階段 Random Forest 分類器，預測違法類型。
6.  返回預測結果。

### 1.5 訓練資料格式

| input_text | label_70_1 | label_70_1_type |
|------------|------------|-----------------|
| 廣告文字     | 0 or 1     | 3 / 4 / 5 / NA   |

*   `label_70_1`: 是否違法（0 = 否，1 = 是）
*   `label_70_1_type`: 違法類型（僅在違法時有值，否則為 `NA`）

### 1.6 預測輸出格式

| 廣告文字 | 是否違法預測 | 違法類型預測 |
|----------|--------------|---------------|
| 廣告內容   | 0 or 1       | `'NA'` 或 `'3'`/`'4'`/`'5'` |

## 2. 技術架構設計

本系統將採用微服務架構，主要分為前端應用、API 服務和 AI 預測服務。

### 2.1 整體架構圖

```mermaid
graph TD
    A[使用者] -->|Web 瀏覽器| B[前端應用 (React/Vue.js)]
    B -->|HTTP/REST API| C[API 服務 (FastAPI/Flask)]
    C -->|gRPC/HTTP| D[AI 預測服務 (Python ML)]
    D --> E[模型儲存 (S3/MinIO)]
    C --> F[資料庫 (PostgreSQL)]
    G[資料科學家/排程] --> H[模型訓練服務 (Python ML)]
    H --> F
    H --> E
```

### 2.2 技術選型

*   **前端框架：** React 或 Vue.js (現代化、組件化開發)
*   **後端 API 服務：** Python FastAPI (高性能、易於開發、自動生成 OpenAPI 文檔)
*   **AI 預測服務：** Python Scikit-learn (TF-IDF, Random Forest), Joblib (模型序列化)
*   **資料庫：** PostgreSQL (關係型資料庫，穩定可靠，支持 JSONB)
*   **模型儲存：** AWS S3 / MinIO (物件儲存，用於存放訓練好的模型文件)
*   **容器化：** Docker (打包應用，確保環境一致性)
*   **部署：** Kubernetes (容器編排，實現高可用和擴展性) 或 Docker Compose (小型部署)
*   **版本控制：** Git
*   **CI/CD：** GitHub Actions / GitLab CI/CD

## 3. 資料庫設計

我們將設計 `ad_predictions` 表來儲存每次預測的結果，以及 `model_versions` 表來追蹤模型版本。

### 3.1 `ad_predictions` 表

用於儲存廣告文字、預測結果及相關元數據。

```sql
CREATE TABLE ad_predictions (
    id SERIAL PRIMARY KEY,
    ad_text TEXT NOT NULL,
    predicted_is_illegal BOOLEAN NOT NULL, -- 0 (false) or 1 (true)
    predicted_violation_type VARCHAR(10),  -- 'NA', '3', '4', '5'
    prediction_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    model_version_id INT, -- Foreign key to model_versions table
    -- Optionally, if original input CSV has a reason column
    original_label_70_1_reason TEXT,
    CONSTRAINT fk_model_version
        FOREIGN KEY (model_version_id)
        REFERENCES model_versions(id)
);

CREATE INDEX idx_prediction_timestamp ON ad_predictions (prediction_timestamp);
CREATE INDEX idx_predicted_is_illegal ON ad_predictions (predicted_is_illegal);
```

### 3.2 `model_versions` 表

用於追蹤和管理不同版本的訓練模型。

```sql
CREATE TABLE model_versions (
    id SERIAL PRIMARY KEY,
    version_name VARCHAR(50) UNIQUE NOT NULL, -- e.g., 'v1.0', '2023-10-26_retrain'
    model_path_stage1 VARCHAR(255) NOT NULL, -- Path to TF-IDF and RF model for stage 1
    model_path_stage2 VARCHAR(255) NOT NULL, -- Path to RF model for stage 2
    training_data_path VARCHAR(255), -- Path to training data used
    trained_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    accuracy_stage1 REAL,
    accuracy_stage2 REAL,
    is_active BOOLEAN DEFAULT FALSE -- Flag to indicate the currently active model
);
```

### 3.3 `training_data_log` 表 (可選)

用於記錄每次模型訓練所使用的數據集信息。

```sql
CREATE TABLE training_data_log (
    id SERIAL PRIMARY KEY,
    file_name VARCHAR(255) NOT NULL,
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    row_count INT,
    processed_successfully BOOLEAN
);
```

## 4. API 接口設計

API 服務將提供 RESTful 接口供前端及其他服務調用。

### 4.1 認證機制

*   考慮使用 API Key 或 JWT (JSON Web Token) 進行身份驗證。

### 4.2 接口列表

#### 4.2.1 單筆廣告預測

*   **Endpoint:** `POST /api/v1/predict`
*   **描述:** 接收單條廣告文字，返回其違法判斷和類型。
*   **請求頭:**
    *   `Content-Type: application/json`
    *   `Authorization: Bearer <token>` (或 `X-API-Key: <key>`)
*   **請求體:**
    ```json
    {
      "ad_text": "您的廣告內容在此"
    }
    ```
*   **響應體 (成功 - 200 OK):**
    ```json
    {
      "ad_text": "您的廣告內容在此",
      "is_illegal": 1,
      "violation_type": "3",
      "message": "預測成功"
    }
    ```
    或
    ```json
    {
      "ad_text": "您的廣告內容在此",
      "is_illegal": 0,
      "violation_type": "NA",
      "message": "預測成功"
    }
    ```
*   **響應體 (錯誤 - 400 Bad Request / 500 Internal Server Error):**
    ```json
    {
      "error": "錯誤訊息",
      "details": "詳細錯誤描述"
    }
    ```

#### 4.2.2 批次廣告預測

*   **Endpoint:** `POST /api/v1/predict_batch`
*   **描述:** 接收多條廣告文字列表，返回批次預測結果。
*   **請求頭:**
    *   `Content-Type: application/json`
    *   `Authorization: Bearer <token>`
*   **請求體:**
    ```json
    {
      "ad_texts": [
        "廣告內容一",
        "廣告內容二",
        "廣告內容三"
      ]
    }
    ```
*   **響應體 (成功 - 200 OK):**
    ```json
    {
      "results": [
        {
          "ad_text": "廣告內容一",
          "is_illegal": 1,
          "violation_type": "3"
        },
        {
          "ad_text": "廣告內容二",
          "is_illegal": 0,
          "violation_type": "NA"
        },
        {
          "ad_text": "廣告內容三",
          "is_illegal": 1,
          "violation_type": "5"
        }
      ],
      "message": "批次預測成功"
    }
    ```
*   **備註:** 對於非常大的文件，可以考慮文件上傳接口，並以異步方式處理，結果通過 Webhook 或輪詢查詢。

#### 4.2.3 模型再訓練 (管理員接口)

*   **Endpoint:** `POST /api/v1/train_model`
*   **描述:** 觸發模型再訓練。
*   **請求頭:**
    *   `Content-Type: application/json`
    *   `Authorization: Bearer <admin_token>`
*   **請求體 (可選):**
    ```json
    {
      "training_data_path": "s3://my-bucket/latest_training_data.csv",
      "version_name": "v1.1_retrain_20231026"
    }
    ```
*   **響應體 (成功 - 202 Accepted):**
    ```json
    {
      "status": "training_started",
      "message": "模型訓練已啟動，請稍後查詢狀態",
      "job_id": "uuid-of-training-job"
    }
    ```

## 5. 核心功能實作

### 5.1 環境準備

```bash
# 創建虛擬環境
python -m venv venv
source venv/bin/activate # macOS/Linux
# venv\Scripts\activate # Windows

# 安裝依賴
pip install fastapi uvicorn scikit-learn pandas joblib python-multipart psycopg2-binary
```

### 5.2 模型加載與預測邏輯 (AI 預測服務)

```python
# ai_service/model_loader.py
import joblib
import os

# 假設模型文件存儲在 'models/' 目錄下
MODEL_DIR = "models"
TFIDF_VECTORIZER_PATH = os.path.join(MODEL_DIR, "tfidf_vectorizer.joblib")
RF_STAGE1_MODEL_PATH = os.path.join(MODEL_DIR, "rf_stage1_model.joblib")
RF_STAGE2_MODEL_PATH = os.path.join(MODEL_DIR, "rf_stage2_model.joblib")

tfidf_vectorizer = None
rf_stage1_model = None
rf_stage2_model = None

def load_models():
    """加載 TF-IDF Vectorizer 和 Random Forest 模型"""
    global tfidf_vectorizer, rf_stage1_model, rf_stage2_model
    try:
        if not os.path.exists(MODEL_DIR):
            raise FileNotFoundError(f"模型目錄 '{MODEL_DIR}' 不存在。請確保模型已下載。")

        tfidf_vectorizer = joblib.load(TFIDF_VECTORIZER_PATH)
        rf_stage1_model = joblib.load(RF_STAGE1_MODEL_PATH)
        rf_stage2_model = joblib.load(RF_STAGE2_MODEL_PATH)
        print("模型加載成功！")
    except Exception as e:
        print(f"模型加載失敗: {e}")
        # 在生產環境中，這裡應該有更健壯的錯誤處理，例如發送警報

def preprocess_text(text: str) -> str:
    """簡單的文本預處理（可根據實際需求擴展）"""
    if not isinstance(text, str):
        return ""
    return text.strip().lower() # 示例：去除首尾空格並轉小寫

def predict_ad_violation(ad_text: str):
    """
    執行兩階段廣告違法預測。
    返回 (is_illegal, violation_type)
    """
    if tfidf_vectorizer is None or rf_stage1_model is None or rf_stage2_model is None:
        raise RuntimeError("模型尚未加載，請先調用 load_models()")

    processed_text = preprocess_text(ad_text)

    # 轉換為 TF-IDF 特徵
    try:
        text_features = tfidf_vectorizer.transform([processed_text])
    except Exception as e:
        print(f"TF-IDF 轉換失敗: {e}")
        return 0, "ERROR" # 處理邊界情況，例如空字符串

    # 第一階段：判斷是否違法
    is_illegal_pred = rf_stage1_model.predict(text_features)[0]

    violation_type_pred = "NA"
    if is_illegal_pred == 1:
        # 第二階段：判斷違法類型
        violation_type_pred = str(rf_stage2_model.predict(text_features)[0])

    return int(is_illegal_pred), violation_type_pred

# 首次運行時加載模型
load_models()

if __name__ == "__main__":
    # 簡單測試
    sample_ad_legal = "這是一個合法的投資廣告，請安心購買。"
    sample_ad_illegal_type3 = "保證獲利，穩賺不賠！"
    sample_ad_illegal_type4 = "本公司產品絕對優於市場上所有同類產品。"

    is_illegal, v_type = predict_ad_violation(sample_ad_legal)
    print(f"廣告: '{sample_ad_legal}' -> 是否違法: {is_illegal}, 類型: {v_type}")

    is_illegal, v_type = predict_ad_violation(sample_ad_illegal_type3)
    print(f"廣告: '{sample_ad_illegal_type3}' -> 是否違法: {is_illegal}, 類型: {v_type}")

    is_illegal, v_type = predict_ad_violation(sample_ad_illegal_type4)
    print(f"廣告: '{sample_ad_illegal_type4}' -> 是否違法: {is_illegal}, 類型: {v_type}")
```

### 5.3 後端 API 服務 (FastAPI)

```python
# api_service/main.py
from fastapi import FastAPI, HTTPException, Request, Depends, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Optional, Dict
import os
import sys
import logging
import pandas as pd
from io import StringIO

# 將 ai_service 目錄添加到 Python 路徑，以便導入
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'ai_service')))
from ai_service.model_loader import predict_ad_violation, load_models

# 配置日誌
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI(
    title="廣告違法判斷與分類 API",
    description="基於 TF-IDF + Random Forest 的兩階段廣告違法預測系統",
    version="1.0.0"
)

# 模擬 API Key 認證
API_KEY = os.getenv("API_KEY", "your_super_secret_api_key")

async def verify_api_key(request: Request):
    api_key = request.headers.get("X-API-Key")
    if not api_key or api_key != API_KEY:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="無效的 API Key"
        )

# Pydantic 模型定義
class AdTextInput(BaseModel):
    ad_text: str

class AdTextsInput(BaseModel):
    ad_texts: List[str]

class PredictionResult(BaseModel):
    ad_text: str
    is_illegal: int
    violation_type: str

@app.on_event("startup")
async def startup_event():
    logger.info("應用啟動中，加載模型...")
    try:
        load_models()
        logger.info("模型加載完成。")
    except Exception as e:
        logger.error(f"應用啟動失敗，模型加載錯誤: {e}")
        # 在生產環境中，這裡可能需要退出應用或進入維護模式
        raise RuntimeError("無法加載模型，服務無法啟動。")

@app.get("/health")
async def health_check():
    """健康檢查接口"""
    return {"status": "ok", "message": "服務運行正常"}

@app.post("/api/v1/predict", response_model=PredictionResult, dependencies=[Depends(verify_api_key)])
async def predict_single_ad(item: AdTextInput):
    """
    對單條廣告文字進行違法判斷和分類。
    """
    try:
        is_illegal, violation_type = predict_ad_violation(item.ad_text)
        logger.info(f"單筆預測: '{item.ad_text[:30]}...' -> 違法: {is_illegal}, 類型: {violation_type}")
        return PredictionResult(
            ad_text=item.ad_text,
            is_illegal=is_illegal,
            violation_type=violation_type
        )
    except Exception as e:
        logger.error(f"單筆預測時發生錯誤: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"預測失敗: {e}")

@app.post("/api/v1/predict_batch", dependencies=[Depends(verify_api_key)])
async def predict_batch_ads(item: AdTextsInput):
    """
    對多條廣告文字進行批次違法判斷和分類。
    """
    results = []
    for ad_text in item.ad_texts:
        try:
            is_illegal, violation_type = predict_ad_violation(ad_text)
            results.append(PredictionResult(
                ad_text=ad_text,
                is_illegal=is_illegal,
                violation_type=violation_type
            ).dict()) # Convert Pydantic model to dict
        except Exception as e:
            logger.error(f"批次預測中處理 '{ad_text[:30]}...' 時發生錯誤: {e}")
            results.append({
                "ad_text": ad_text,
                "is_illegal": -1, # Use -1 to indicate error for this specific item
                "violation_type": "ERROR",
                "error_message": str(e)
            })
    logger.info(f"批次預測完成，共處理 {len(item.ad_texts)} 條廣告。")
    return {"results