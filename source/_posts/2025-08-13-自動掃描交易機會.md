---
title: 自動掃描交易機會
date: 2025-08-13 23:23:59
subtitle: 自動掃描交易機會
categories:
  - Web Development
tags:
  - fintech
  - ai
  - web-development
  - api
  - tutorial
---

# 使用現代前端技術與 AI 打造智慧選股應用：Kairis App 實戰指南

## 導言

本篇文章旨在深入探討 Kairis App 的技術架構與實作細節。Kairis 是一款專為投資者設計的行動優先網頁應用程式 (SPA)，其核心目標是提供一個簡潔高效的介面，讓使用者能夠追蹤自選的美股與台股、透過多維度技術指標自動掃描交易機會，並結合 AI 智慧解讀，輔助使用者做出更全面的投資決策。

本文將引導讀者了解 Kairis App 所使用的關鍵技術棧、環境設定、核心功能模組的技術實現思路，並提供實用的程式碼範例，幫助您理解如何整合前端、後端無伺服器函式、資料庫與多個外部 API，共同構建一個功能強大的智慧選股工具。無論您是想學習現代網頁開發、API 整合，或是對金融科技應用有興趣，本文都將提供寶貴的實踐經驗。

## 前置需求

在開始實作之前，請確保您的開發環境已具備以下工具與知識：

1.  **Node.js 與 npm (或 Yarn)**：用於專案的套件管理與執行環境。建議使用 LTS 版本。
2.  **Git**：版本控制工具，用於克隆專案程式碼。
3.  **程式碼編輯器**：推薦使用 Visual Studio Code，並安裝相關擴充功能 (如 Tailwind CSS IntelliSense)。
4.  **網頁瀏覽器**：用於測試應用程式。
5.  **GitHub 帳戶**：用於克隆 Kairis App 的開源專案。
6.  **Vercel 帳戶**：用於部署無伺服器函式與前端應用。
7.  **Google Firebase 專案**：用於設定 Firestore 資料庫與匿名身份驗證。
8.  **API 金鑰**：
    *   **Finnhub API Key**：用於獲取美股即時報價與公司新聞。
    *   **Alpha Vantage API Key**：用於獲取穩定的每日歷史 K 線數據。
    *   **Google Cloud Console 專案與 Gemini API Key**：用於 AI 智慧解讀與新聞標題翻譯。
9.  **基本網頁開發知識**：熟悉 HTML、CSS (尤其是 Tailwind CSS 的概念) 和 Vanilla JavaScript。
10. **RESTful API 概念**：了解如何發送 HTTP 請求與處理 API 回應。

## 實作步驟

本節將詳細說明 Kairis App 的技術設定與核心功能模組的實現方式。

### 1. 專案初始化與環境設定

首先，我們需要克隆 Kairis App 的 GitHub 儲存庫並安裝必要的依賴。

```bash
# 克隆專案儲存庫
git clone https://github.com/cleoliu/StockWise.git

# 進入專案目錄
cd StockWise

# 安裝專案依賴
npm install
# 或者使用 yarn install
```

接下來，您需要設定環境變數來儲存敏感的 API 金鑰。在專案根目錄下創建一個 `.env` 或 `.env.local` 檔案，並填入您的 API 金鑰。這些變數將在 Vercel 部署時被注入到無伺服器函式中。

```
# .env.local 檔案範例
FINNHUB_API_KEY=your_finnhub_api_key_here
ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_here
GEMINI_API_KEY=your_gemini_api_key_here

# Firebase 配置資訊 (通常在前端直接使用，但如果需要伺服器端初始化則也需在此設定)
# VITE_FIREBASE_API_KEY=...
# VITE_FIREBASE_AUTH_DOMAIN=...
# VITE_FIREBASE_PROJECT_ID=...
# ...等等，具體參考Firebase設定
```

### 2. Firebase 資料庫設定與匿名登入

Kairis App 使用 Google Firebase 的 Firestore 作為資料庫，用於儲存使用者的自選股列表，並透過匿名登入機制提供無需註冊的便利性。

#### 2.1 Firebase 專案設定

1.  前往 [Firebase Console](https://console.firebase.google.com/)，創建一個新專案。
2.  在專案中啟用 **Firestore Database**。選擇「Start in production mode」並設定資料庫位置。
3.  在「Build」->「Authentication」中啟用 **匿名 (Anonymous)** 登入方法。

#### 2.2 前端 Firebase 初始化與匿名登入邏輯

前端應用需要初始化 Firebase SDK 並處理匿名登入。

```javascript
// src/firebase-config.js (假設的 Firebase 設定檔案)
import { initializeApp } from 'firebase/app';
import { getFirestore, doc, setDoc, getDoc } from 'firebase/firestore';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';

// 您的 Firebase 專案配置 (從 Firebase Console 取得)
const firebaseConfig = {
  apiKey: "YOUR_FIREBASE_API_KEY",
  authDomain: "YOUR_FIREBASE_AUTH_DOMAIN",
  projectId: "YOUR_FIREBASE_PROJECT_ID",
  storageBucket: "YOUR_FIREBASE_STORAGE_BUCKET",
  messagingSenderId: "YOUR_FIREBASE_MESSAGING_SENDER_ID",
  appId: "YOUR_FIREBASE_APP_ID"
};

// 初始化 Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// 處理匿名登入
export const setupAnonymousAuth = async () => {
  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      try {
        const userCredential = await signInAnonymously(auth);
        console.log("匿名登入成功:", userCredential.user.uid);
        // 在此可以初始化使用者的自選股列表或其他設定
        await setDoc(doc(db, "users", userCredential.user.uid), {
          watchlist: [],
          createdAt: new Date()
        }, { merge: true });
      } catch (error) {
        console.error("匿名登入失敗:", error);
      }
    } else {
      console.log("使用者已登入:", user.uid);
    }
  });
};

// 儲存或更新使用者自選股列表的範例函式
export const saveUserWatchlist = async (userId, watchlist) => {
  try {
    await setDoc(doc(db, "users", userId), { watchlist }, { merge: true });
    console.log("自選股列表已更新。");
  } catch (error) {
    console.error("更新自選股列表失敗:", error);
  }
};

// 獲取使用者自選股列表的範例函式
export const getUserWatchlist = async (userId) => {
  try {
    const userDocRef = doc(db, "users", userId);
    const userDocSnap = await getDoc(userDocRef);
    if (userDocSnap.exists()) {
      return userDocSnap.data().watchlist || [];
    }
    return [];
  } catch (error) {
    console.error("獲取自選股列表失敗:", error);
    return [];
  }
};

// 在應用程式啟動時呼叫
// setupAnonymousAuth();
```

### 3. Vercel Serverless Functions 與 API 整合

Kairis App 的後端邏輯主要由 Vercel Serverless Functions 實現。這些函式充當前端與外部 API 之間的橋樑，負責：

*   隱藏 API 金鑰，避免暴露在前端。
*   處理 CORS (跨域資源共享) 問題。
*   聚合來自不同 API 的數據。
*   執行複雜的計算邏輯，例如「機會掃描」的力度評分。

#### 3.1 股票報價與歷史數據 API

我們透過 Finnhub 獲取即時報價，並透過 Alpha Vantage 獲取穩定的歷史 K 線數據。

```javascript
// api/stock-data.js (Vercel Serverless Function 範例)
import fetch from 'node-fetch'; // 在 Node.js 18+ 環境中可直接使用內建的 fetch

export default async function handler(req, res) {
  const { symbol, market } = req.query; // market 可以是 'US' 或 'TW'
  const finnhubApiKey = process.env.FINNHUB_API_KEY;
  const alphaVantageApiKey = process.env.ALPHA_VANTAGE_API_KEY;

  if (!symbol) {
    return res.status(400).json({ error: '股票代號為必填項' });
  }

  try {
    // 獲取即時報價 (Finnhub)
    const quoteRes = await fetch(`https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${finnhubApiKey}`);
    const quoteData = await quoteRes.json();

    // 獲取歷史K線數據 (Alpha Vantage)
    // 這裡只是一個範例，實際應用中會根據需求選擇日線或週線
    const klineRes = await fetch(`https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=${alphaVantageApiKey}`);
    const klineData = await klineRes.json();

    // 檢查 API 回應是否成功
    if (quoteRes.status !== 200 || klineRes.status !== 200) {
        throw new Error('API 請求失敗');
    }

    // 處理 Alpha Vantage 的錯誤訊息
    if (klineData["Error Message"] || klineData["Note"]) {
        console.warn(`Alpha Vantage API 警告或錯誤 for ${symbol}:`, klineData["Error Message"] || klineData["Note"]);
        // 選擇性地拋出錯誤或返回部分數據
    }

    // 將兩個 API 的數據整合
    const combinedData = {
      symbol: symbol,
      market: market,
      currentPrice: quoteData.c,
      change: quoteData.d,
      percentChange: quoteData.dp,
      high: quoteData.h,
      low: quoteData.l,
      open: quoteData.o,
      previousClose: quoteData.pc,
      volume: quoteData.v,
      historicalData: klineData["Time Series (Daily)"] // 簡化處理，實際需解析
    };

    res.status(200).json(combinedData);
  } catch (error) {
    console.error(`獲取 ${symbol} 數據失敗:`, error);
    res.status(500).json({ error: '無法獲取股票數據', details: error.message });
  }
}
```

#### 3.2 Gemini AI 智慧解讀與翻譯

Gemini API 用於生成技術面綜合分析和新聞標題的自動翻譯。

```javascript
// api/gemini-ai.js (Vercel Serverless Function 範例)
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-pro" });

export default async function handler(req, res) {
  const { type, content } = req.body;

  if (!type || !content) {
    return res.status(400).json({ error: '請求類型和內容為必填項' });
  }

  try {
    let prompt = '';
    if (type === 'analyze_stock') {
      // 這裡的 content 應該包含股票的技術指標數據
      prompt = `請根據以下股票的技術指標數據，提供一份簡潔的技術面綜合分析（約100字）：\n\n${content}\n\n請以繁體中文回答。`;
    } else if (type === 'translate_news') {
      prompt = `請將以下英文新聞標題翻譯成繁體中文，並截斷過長的標題（約20字內）：\n\n"${content}"`;
    } else {
      return res.status(400).json({ error: '不支援的請求類型' });
    }

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    res.status(200).json({ result: text });
  } catch (error) {
    console.error("Gemini AI 處理失敗:", error);
    res.status(500).json({ error: 'AI 服務錯誤', details: error.message });
  }
}
```

#### 3.3 機會掃描力度評估邏輯

「機會掃描」頁面的力度評估邏輯通常會整合在一個後端函式中，該函式會從資料庫獲取使用者自選股列表，然後呼叫多個 API 獲取最新的價格、趨勢、動能和成交量數據，並根據預設的規則進行評分。這部分邏輯會比較複雜，通常涉及多個技術指標的計算與條件判斷。

**概念性邏輯 (位於後端 Serverless Function 中):**

```javascript
// api/scan-opportunities.js (概念性 Vercel Serverless Function)
// 此處省略了從 Firebase 獲取使用者自選股列表的邏輯
// 以及從 Finnhub/Alpha Vantage 獲取多個股票數據的邏輯

export default async function handler(req, res) {
  // 假設我們已經獲取了所有自選股的最新數據
  const stocksData = [
    // { symbol: 'AAPL', currentPrice: 175, ma5: 176, rsi: 60, macd: { hist: 0.5 }, volume: 100000000, avgVolume: 90000000, ... },
    // ...
  ];

  const opportunities = [];

  for (const stock of stocksData) {
    let strengthScore = 0;
    const reasons = [];

    // 1. 價格指標 (RSI, 布林通道)
    if (stock.rsi && stock.rsi < 30) { // RSI 超賣
      strengthScore += 1;
      reasons.push("RSI 超賣");
    }
    // if (stock.price < stock.bollingerLowerBand) { // 跌破布林下軌
    //   strengthScore += 1;
    //   reasons.push("跌破布林通道下軌");
    // }

    // 2. 趨勢指標 (均線)
    if (stock.currentPrice > stock.ma5 && stock.ma5 > stock.ma10) { // 短期均線多頭排列
      strengthScore += 1;
      reasons.push("短期均線多頭排列");
    }
    // if (stock.currentPrice > stock.ma20) { // 站上20日線
    //   strengthScore += 1;
    //   reasons.push("站上20日均線");
    // }

    // 3. 動能指標 (MACD 交叉)
    // if (stock.macd && stock.macd.signalCrossedAboveMACD) { // MACD 黃金交叉
    //   strengthScore += 1;
    //   reasons.push("MACD 黃金交叉");
    // }

    // 4. 成交量 (價量關係)
    if (stock.volume > (stock.avgVolume * 1.5) && stock.currentPrice > stock.previousClose) { // 價漲量增
      strengthScore += 1;
      reasons.push("價漲量增");
    }

    if (strengthScore > 0) {
      opportunities.push({
        symbol: stock.symbol,
        name: stock.name, // 假設有股票名稱
        currentPrice: stock.currentPrice,
        change: stock.change,
        percentChange: stock.percentChange,
        reasons: reasons,
        strength: Math.min(strengthScore, 3) // 力度評分限制在 1-3 分
      });
    }
  }

  // 依照力度由高至低排序
  opportunities.sort((a, b) => b.strength - a.strength);

  res.status(200).json({ opportunities });
}
```

### 4. 前端介面與資料呈現

Kairis App 的前端採用純 HTML、Tailwind CSS 和 Vanilla JavaScript 構建，以實現輕量級和高效能的行動優先體驗。

#### 4.1 核心介面佈局

應用程式使用深色主題，並以固定的底部頁籤列 (`Tab Bar`) 作為主要導覽，包含「自選列表」和「機會掃描」。

```html
<!-- index.html 結構概覽 -->
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kairis App</title>
    <!-- 引入 Tailwind CSS -->
    <link href="./output.css" rel="stylesheet">
    <style>
        body {
            background-color: #1a202c; /* 深色背景 */
            color: #e2e8f0; /* 淺色文字 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        /* 其他自定義樣式 */
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col">

    <header class="p-4 text-center text-2xl font-bold border-b border-gray-700">
        Kairis App
    </header>

    <main class="flex-grow p-4 overflow-y-auto">
        <!-- 內容區域會根據